#!/usr/bin/env python3

from __future__ import division
import rosbag, rospy, numpy as np
import sys, os, cv2, glob
from itertools import repeat
import imageio
import argparse
import logging
import traceback
from pathlib import Path
from cv_bridge import CvBridge

import re

#import imaging_sonar_msgs
#import draw_sonar


def get_sizes(bag, topics=None, index=0, scale=1.0, start_time=rospy.Time(0), stop_time=rospy.Time(sys.maxsize)):
    logging.debug("Resizing height to topic %s (index %d)." % (topics[index] , index))
    sizes = []

    for topic in topics:
        try:
            iterator = bag.read_messages(topics=topic, start_time=start_time, end_time=stop_time)#, raw=True)
            msg = next(iterator)[1] # read one message

            if re.match("imaging_sonar_msgs/ImagingSonarMsg", msg._type):
                logging.warning("Imaging sonar message")

                if len(sizes) > 0:
                    height = sizes[0][1]
                else:
                    height = 1024

                ## \todo get image size from serdp_common
                width = draw_sonar.calculateImageWidth(height)

                sizes.append((width,height))

            else:
                sizes.append((msg.width, msg.height))

        except:
            logging.critical("No messages found for topic %s, or message does not have height/width." % topic)
            traceback.print_exc()
            sys.exit(1)

    target_height = int(sizes[index][1]*scale)

    # output original and scaled sizes
    for i in range(len(topics)):
        logging.info('Topic %s originaly of height %s and width %s' % (topics[i],sizes[i][0],sizes[i][1]))
        image_height = sizes[i][1]
        image_width = sizes[i][0]

        # rescale to desired height while keeping aspect ratio
        sizes[i] = (int(1.0*image_width*target_height/image_height),target_height)
        logging.info('Topic %s rescaled to height %s and width %s.' % (topics[i],sizes[i][0],sizes[i][1]))

    return sizes

def draw_msg( msg, encoding ):
    if re.match("imaging_sonar_msgs/ImagingSonarMsg", msg._type):
        return np.zeros( (100,100,3), dtype=np.uint8 )
    else:
        return np.asarray(CvBridge().imgmsg_to_cv2(msg, encoding))

def calc_out_size(sizes):
    return (sum(size[0] for size in sizes),sizes[0][1])

def merge_images(images, sizes):
    return cv2.hconcat([cv2.resize(images[i],sizes[i]) for i in range(len(images))])

def write_frames(bag, outdir, topics, sizes, start_time=rospy.Time(0),
                    stop_time=rospy.Time(sys.maxsize), encoding='bgr8', skip=1,
                    sequence_number=False, skip_till_all_topics=False ):

    convert = { topics[i]:i for i in range(len(topics))}

    present = { topic: False for topic in topics }
    images = [np.zeros((sizes[i][1],sizes[i][0],3), np.uint8) for i in range(len(topics))]

    frame_num = 0

    iterator = bag.read_messages(topics=topics, start_time=start_time, end_time=stop_time)

    for count, msg_tuple in enumerate(iterator):

        topic, msg, t = msg_tuple

        present[topics] = True

        time=t.to_sec()

        logging.debug('Topic %s, seq %d, updated at time %s seconds' % (topic, msg.header.seq, time ))

        images[convert[topic]] = draw_msg( msg, encoding )

        if skip_till_all_topics and not all( v for v in present.values() ):
            continue

        if (count % skip == 0):

            # record the current information up to this point in time
            merged_image = merge_images(images, sizes)

            if sequence_number:
                image_name = "image_seq_%06d.png" % msg.header.seq
            else:
                image_name = "image_%06d.png" % count

            outpath = outdir / image_name
            logging.info('Writing image %d, seq %d, at time %.6f seconds to %s' % (count, msg.header.seq, time, outpath) )
            imageio.imwrite( outpath, merged_image )



if __name__ == '__main__':

    ## /todo Add option to _not_ write images until every topic has been seen once
    ##       Prevents initial frames from having one or more dark panels when
    ##       compositing multiple topics

    parser = argparse.ArgumentParser(description='Extract and encode video from bag files.')

    parser.add_argument('bagfile', help='Specifies the location of the bag file.')
    parser.add_argument('topics', nargs='+',help='Image topics to merge in output video.')
    parser.add_argument('--index', '-i', action='store',default=0, type=int,
                        help='Resizes all images to match the height of the topic specified. Default 0.')
    parser.add_argument('--scale', '-x', action='store',default=1, type=float,
                        help='Global scale for all images. Default 1.')
    parser.add_argument('--outdir', '-o', action='store', required=True, type=Path,
                        help='Destination directory for output')

    parser.add_argument('--start', '-s', action='store', default=0, type=float,
                        help='Rostime representing where to start in the bag.')
    parser.add_argument('--end', '-e', action='store', default=sys.maxsize, type=float,
                        help='Rostime representing where to stop in the bag.')

    parser.add_argument('--skip', default=1, type=int,
                        help='Extract every N\'th image.')

    parser.add_argument('--sequence-number', action="store_true", help="Label images with ROS header sequence number instead of frame within bag" )
    parser.add_argument('--skip-till-all-topics', action="store_true", help="Skip writing images until all topics are represented")

    parser.add_argument('--encoding', choices=('rgb8', 'bgr8', 'mono8'), default='bgr8',
                        help='Encoding of the deserialized image. Default bgr8.')

    # Can specify either --verbose or --log;  --log takes precedence
    parser.add_argument('--log', '-l',action='store',default='INFO',
                        help='Logging level. Default INFO.')
    parser.add_argument('-v', '--verbose', action='count', default=0)

    args = parser.parse_args()

    # logging setup
    if args.log:
        numeric_level = getattr(logging, args.log.upper(), None)
    else:
        numeric_level = args.verbose

    if not isinstance(numeric_level, int):
        raise ValueError('Invalid log level: %s' % loglevel)
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s',level=numeric_level)

    args.outdir.mkdir(exist_ok=True)

    if args.sequence_number and len(args.topics) > 1:
        logging.critical("Can only do --sequence with one topic")
        sys.exit(-1)

    # convert numbers into rospy Time
    start_time=rospy.Time(args.start)
    stop_time=rospy.Time(args.end)

    try:
        assert start_time <= stop_time
    except:
        logging.critical("Start time is after stop time.")
        traceback.print_exc()
        sys.exit(-1)

    try:
        assert args.index < len(args.topics)
    except:
        logging.critical("Index specified for resizing is out of bounds.")
        traceback.print_exc()
        sys.exit(-1)

    for bagfile in glob.glob(args.bagfile):
        logging.info('Proccessing bag %s.'% bagfile)
        bag = rosbag.Bag(bagfile, 'r')

        logging.info('Calculating video sizes.')
        sizes = get_sizes(bag, topics=args.topics, index=args.index,scale = args.scale,
                            start_time=start_time, stop_time=stop_time)

        logging.info('Calculating final image size.')
        out_width, out_height = calc_out_size(sizes)
        logging.info('Resulting video of width %s and height %s.'%(out_width,out_height))

        write_frames(bag=bag, outdir=args.outdir, topics=args.topics, sizes=sizes,
                         start_time=start_time, stop_time=stop_time, encoding=args.encoding, skip=args.skip,
                        sequence_number=args.sequence_number, skip_till_all_topics=args.skip_till_all_topics )

        logging.info('Done.')
